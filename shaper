二次入队shaper
测试步骤：1、按照组网图建立拓扑结构 2、配置通用调度器0下挂的3条队列为SP调度，通用调度器7下挂的2条队列为WRR调度，调度比例为1:2 3、配置协议通路转发，使满足以下转发：  数据流1，进入队列0后，二次入队进入tcont0的队列0； 数据流2，进入队列1后，二次入队进入tcont0的队列0； 数据流3，进入队列2后，二次入队进入tcont1的队列0； 数据流4，进入队列3后，二次入队进入tcont2的队列0； 数据流4，进入队列4后，二次入队进入tcont3的队列0； 4、配置通用调度器0的shaper为80M，通用调度器7的shaper为60M 5、使用测试仪发送数据流1-5各50M，观测tcont0~3收到的流量
样本点：测试队列： 通用调度器0 输入端0-2挂的队列0-2； 通用调度器7 输入端0-1挂的队列3-4； 发送包长：64 2000 随机
预期：1、步骤5，tcont0收到的流量为30M，tcont1收到的流量为50M，tcont2收到的流量为20M，tcont3收到的流量为40M

.app.tcl文件：

namespace eval TestApp {
 

    proc TestLogic { args } {

		# 环境信息清理动作
		AsicEnvironmentInfoInitialization


        #===================================================================================
        #  系统变量，测试人员不可更改
        #===================================================================================
        set strCmd "===================Begin:$aTestCaseData(testCaseNo)============\033\033"
        ::Common::CSend $term1 -r strRet1 -s [list "#"] -t 10000 "$strCmd"
                
        
        #获取测试数据，重新封装到数组Data里去
        CommonArgsToArray $aTestCaseData(args) Data
		
	 	#当前目录下执行的测试逻辑文件
        set strFileName [string map {app.tcl txt} $::TestLib::naLibData(testLogicFileName)]
      	#使用parseLogicFile执行测试逻辑
        set res [parseLogicFile $strFileName]
		#　收集环境信息
		AsicEnvironmentInfoCollect $res


        ::TestLib::ShowTraceMessage -level 10 "result == $res"
        #返回执行结果
        return $res
    }
    #===================================================================================
    # 系统函数调用，测试人员不可更改
    #   测试逻辑执行入口
    #===================================================================================
    #!!================================================================
    #过 程 名：    Main
    #程 序 包：
    #功能类别：
    #过程描述：    （包含范例）
    #   载入package TestLib
    #   执行测试逻辑
    #参数说明：
    #返 回 值：
    #   0:  执行成功
    #   1:  执行失败
    #函数作者：    Peixing.Lin.(14507)
    #生成日期：    2003-03-04 20:04:06
    #修改纪录：
    #!!================================================================
    proc Main {} {
        global auto_path
        
        # 默认执行成功
        set result 0
        if {([lsearch -exact [namespace children ::] ::TestLib] != -1)} {
            # 如果TestLib已经载入，则退出；
            return $result
        }
        set sTestLibDir             "Lib/CommonLib"
        set sScriptsDir             "Scripts"
        set sTestLogicFilePathName  ""
        set sAutoTestPath           ""
        set sTestLibPath            ""
        # 得到带绝对路径的测试逻辑文件名
        set sTestLogicFilePathName  [info script]
        if { $sTestLogicFilePathName == "" } {
            set sTestLogicFilePathName  [tgetcurfilepath]
        }

        set lPath   [file split $sTestLogicFilePathName]
        # 得到Scripts目录名在测试逻辑路径列表中的索引
        set iIdx -1
        for { set i 0 } { $i < [llength $lPath] } { incr i} {
            # 不区分大小写
            if { [string equal -nocase $sScriptsDir [lindex $lPath $i]] != 1} {
                continue
            }
            set iIdx $i
            break
        }
        
        #set iIdx    [lsearch -exact $lPath $sScriptsDir]
        if {  -1 == $iIdx } {
            puts "TestApp-测试逻辑脚本没有按照目录结构的定义放在规定的位置Scripts目录下!"
            set result 1
            return $result
        } else {
            #取得自动化工作目录
            set sAutoTestPath [lindex $lPath 0]
            for {set i 1} {$i < $iIdx} {incr i} {
                set sAutoTestPath [file join $sAutoTestPath [lindex $lPath $i]]
            }
        }

        # 得到package TestLib函数库所在的路径
        set sTestLibPath [file join $sAutoTestPath $sTestLibDir]

        # 将自动化体系的函数库的路径加入tcl系统函数库路径变量中
        lappend auto_path $sTestLibPath
        # 如果没有包索引文件，则创建
        if { ![file exists [file join $sTestLibPath "pkgIndex.tcl"]] } {
            if {[catch [list pkg_mkIndex $sTestLibPath *.tcl] errMsg]} {
                puts "TestApp: 创建运行引索引失败！"
                puts "TestApp: 失败信息：$errMsg"
                set result 1
                return $result
            }
        }
        # 载入package TestLib
        set status [ catch { package require TestLib } pkgVersion ]
        if { $status != 0 } {
            puts "TestApp: 无法找到TestLib的路径；\n$::auto_path\n错误信息: $pkgVersion\n"
            set result 1
            return $result
        } else {
            puts "TestApp: 载入测试包TestLib,版本号：$pkgVersion"
        }
        # 调用支撑代码接口，执行测试逻辑
        set result [::TestLib::RunEngine    ::TestApp::TestLogic     $sTestLogicFilePathName]

        return $result
    }
}

# 测试逻辑执行入口点
::TestApp::Main
#--<end>--


.cfg文件：
[TestLogicInfo]
testClusterNames= IasGlobal/AsicQOSTc
productLib=
toolLib=

# 在TERM1控制台窗口上的建立/恢复配置命令/脚本 
TERM1,SetupCommands=
TERM1,RestoreCommands=
TERM1,SetupScripts=
#0小时 10分钟 47秒
[TestCaseData]
FIELDS,      testCaseNo,        testClusters,      testCaseName,      	testCaseLevel,			args,    
1, QOS_Shaper_08_010,  IasGlobal/AsicQOSTc, 二次入队_shaper, $chipVersion$execNetWorkQos0$caseLevel0, \
-vlan0 $oltCvlanId -vlan1 $oltCvlanId1 -vlan2 $oltCvlanId2 -vlan3 $oltCvlanId3 -egr $up_port_num \
-sfc_id0 0 -sfc_id1 1 -sfc_id2 2 -sfc_id3 3 -rate0 5000 -rate1 3750 \
-forward {0.0 30000 50000 [expr 1 * 1.0 / 3 * 60 * 1000] [expr 2 * 1.0 / 3 * 60 * 1000]} \
-forwardMix  " {-streamNO {0 1 2 3 4  } -tsStreamNO {0 1 2 3 4  } -checktype bps \
                 -forwardValue {0 30 50 [expr 1 * 1.0 / 3 * 60 ] [expr 2 * 1.0 / 3 * 60 ] } }  \
              " \
,                                                     

.txt文件：
#逻辑编号:
逻辑名称:二次入队_shaper
逻辑说明:
组网编号: 
预置条件:
测试步骤:

020. 清除统计信息:
     CntAllClr (-TermName $term3);

020. 清除所有队列统计:
     QosQueueCntAllClr (-TermName $term3); 
     
030 清除ont本地arl表:
	L2MacAllDel (-TermName $term3);

050 配置TCONT绑定模板:
	IasOntLineProfileAdd (-TermName $term1  -OntLineProfileType gpon  -ProfileId $ontLineProfileId); 
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId0  -DbaProfileId $dbaProfileId2);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId1  -DbaProfileId $dbaProfileId2);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId2  -DbaProfileId $dbaProfileId2);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId3  -DbaProfileId $dbaProfileId2);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId4  -DbaProfileId $dbaProfileId2);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId5  -DbaProfileId $dbaProfileId2);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId6  -DbaProfileId $dbaProfileId2);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId7  -DbaProfileId $dbaProfileId2);

050 配置端口加入vlan:
 	L2BcSet (-TermName $term3 -vlan $Data(vlan0) -user_vlan $Data(vlan0) -egr $Data(egr)); 
 	L2BcSet (-TermName $term3 -vlan $Data(vlan1) -user_vlan $Data(vlan1) -egr $Data(egr));
 	L2BcSet (-TermName $term3 -vlan $Data(vlan2) -user_vlan $Data(vlan2) -egr $Data(egr));
 	L2BcSet (-TermName $term3 -vlan $Data(vlan3) -user_vlan $Data(vlan3) -egr $Data(egr));
 	
090 配置预调度所挂队列: 
   func_qos_presch_create(-TermName $term3 -id 0);
   func_qos_presch_create(-TermName $term3 -id 1);
   QosGssaTableSet (-TermName $term3 -index 17 -eqm_chid 16 -input0_gnum 0 -input1_gnum 1 -input2_gnum 1 -input3_gnum 1 -input4_gnum 1 -input5_gnum 1 -input6_gnum 1 -input7_gnum 1); 
   QosGssaTableSet (-TermName $term3 -index 18 -eqm_chid 16 -input0_gnum 0 -input1_gnum 0 -input2_gnum 0 -input3_gnum 0 -input4_gnum 0 -input5_gnum 0 -input6_gnum 0 -input7_gnum 0);

   
090 配置预调度的调度器shaper: 
   QosShtTableSet (-TermName $term3 -index 1 -xir $Data(rate0) -xbs 15625);
   QosSsctTableSet (-TermName $term3 -index 17 -pir_shp_mnum 1 -sshp_mode 0);
   QosShtTableSet (-TermName $term3 -index 18 -xir $Data(rate1) -xbs 15625);
   QosSsctTableSet (-TermName $term3 -index 17 -pir_shp_mnum 1 -sshp_mode 0);


    AsicCurCfgGet (-TermName $term3 );
    
080 配置预调度队列入队映射表:
    GponMapSfcSet(-TermName $term3 -sfc_id 0 -pre_sch_en 1 -valid 1 -pre_sch 0);
    GponMapSfcSet(-TermName $term3 -sfc_id 1 -pre_sch_en 1 -valid 1 -pre_sch 0);
    GponMapSfcSet(-TermName $term3 -sfc_id 2 -pre_sch_en 1 -valid 1 -pre_sch 0);
    GponMapSfcSet(-TermName $term3 -sfc_id 3 -pre_sch_en 1 -valid 1 -pre_sch 0);
    GponMapSfcSet(-TermName $term3 -sfc_id 4 -pre_sch_en 1 -valid 1 -pre_sch 0);
    GponMapSfcSet(-TermName $term3 -sfc_id 5 -pre_sch_en 1 -valid 1 -pre_sch 1);
    GponMapSfcSet(-TermName $term3 -sfc_id 6 -pre_sch_en 1 -valid 1 -pre_sch 1);
    GponMapSfcSet(-TermName $term3 -sfc_id 7 -pre_sch_en 1 -valid 1 -pre_sch 1);
    

     
130 往测试队列发送报文:
    QosCheckNoFullStremMixData ( \
                        -OltSvlanId $oltSvlanId -BlackStreamFlg $blackStreamFlg \
                        -TsuID $tsuID -StreamSum 5 -Speed 25 \
	                    -SendPort $sendPort -StaPort $staPort -StatMode $statMode -Vlan "$Data(vlan0) $Data(vlan0) $Data(vlan1) $Data(vlan2) $Data(vlan3)" \
	                    -Pri $port5_vlanPri -SMac $port5_sourceMAC -DMac $port5_destinationMAC \
                        -SampleTimes $sampleTimes -PktLenList $pktLenList \
                        -SaveCfgFile $saveCfgtoFile -StaItem $statItem \
                        -StatIteStopStream $statIteStopStream \
						-AllowError $allowErrorQOSbps \
						-AllowErrorFittery $allowErrorFittery \
						-PayLoad  INCRBYTE \
                        );

资源释放：
010 删除预调度的调度器shaper:
   QosSsctTableSet (-TermName $term3 -index 17 -pir_shp_mnum 0 -sshp_mode 0);
   QosSsctTableSet (-TermName $term3 -index 18 -pir_shp_mnum 0 -sshp_mode 0);

020 延迟一段时间:
    IasCommonDelay( -Time $waitTime);
    
050 删除端口加入vlan:
 	L2BcAllDel (-TermName $term3 -vlan $Data(vlan0)); 
 	L2BcAllDel (-TermName $term3 -vlan $Data(vlan1));
 	L2BcAllDel (-TermName $term3 -vlan $Data(vlan2));
 	L2BcAllDel (-TermName $term3 -vlan $Data(vlan3));
 	


100 恢复二次入队的GSSA表配置:
 	QosGssaTableSet (-TermName $term3 -index 17 -schrule_sel 0 -input0_gnum 7 \
 	-input1_gnum 6 -input2_gnum 5 -input3_gnum 4 -input4_gnum 3 -input5_gnum 2 -input6_gnum 1 -input7_gnum 0);

    
110 恢复TCONT绑定模板:
	IasOntLineProfileAdd (-TermName $term1  -OntLineProfileType gpon  -ProfileId $ontLineProfileId);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId1  -DbaProfileId $dbaProfileId1);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId2  -DbaProfileId $dbaProfileId1);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId3  -DbaProfileId $dbaProfileId1);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId4  -DbaProfileId $dbaProfileId1);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId5  -DbaProfileId $dbaProfileId1);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId6  -DbaProfileId $dbaProfileId1);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId7  -DbaProfileId $dbaProfileId1);
	IasNewModeOntTcontBind (-TermName $term1  -ProfileId $ontLineProfileId  -TcontId $tcontId0  -DbaProfileId $dbaProfileId);

234.停流:
    QosTsuRemoveStream (-TsuID $tsuID -Port $sendPort);
    AsicCurCfgGet (-TermName $term3 );

部分函数：

	#!!================================================================
	#  过 程 名：	IasOntLineProfileAdd
	#  函数说明：	创建并进入指定的ONT线路模板配置模式
	#  参数说明：
	#               -TermName:           (必选)窗口名； 
	#               -OntLineProfileType:(必选)线路模板类型gpon或epon
	#               -ProfileId:         (可选)ONT线路模板编号
    #               -ProfileName:       (可选)ONT线路模板名
	#  返 回 值：	
	#			  错误返回错误列表,正确无返回值
	#
	#  注意事项： 
	#  使用实例： 
	#               IasOntLineProfileAdd -TermName TERM1 -OntLineProfileType gpon -ProfileId 30
	#  对应命令： 
	#               ont-lineprofile gpon profile-id 30
	#               
	#	   
	#  作    者：   xiaofei 00110447  
	#  生成时间：   2008-8-18
	#  修改纪录：   2008-8-28 x00110447 修改命令行
	#               2008-8-30 x00110447 添加Suc001
	#              
	#!!================================================================
	
	proc IasOntLineProfileAdd { args } {
	    #-----------------------------------
		#  定义私有标签码
		#-----------------------------------
		
		#--------------------------------------------
		# 定义CommonCommand的函数的各个参数
		#--------------------------------------------
		#1.返回值规则列表: 
		set Err001 {Failure:\s*The\s*profile\s*type\s*is\s*not\s*EPON}
		set Err001Msg {模板类型不是EPON,无法进入EPON线路配置模式,请进入GPON模板配置模式}
		set Err002 {Failure:\s*The\s*profile\s*type\s*is\s*not\s*GPON}
		set Err002Msg {模板类型不是GPON,无法进入GPON线路配置模式,请进入GPON模板配置模式}
		set Err003 {Failure:\s*The\s*profile\s*name\s*is\s*different\s*with\s*the\s*name\s*which\s*is\s*used\s*by\s*the\s*input\s*profile\s*ID}
		set Err003Msg {模板名称与所输入的模板ID使用的名称不同,请使用指定ID的模板名称}
		set Err004 {Failure:\s*The\s*profile\s*number\s*has\s*already\s*reach\s*the\s*upper\s*limit}
		set Err004Msg {模板已达最大规格}
		set Err005 {Failure:\s*The\s*profile\s*name\s*is\s*not\s*the\s*default\s*name}
		set Err005Msg {模板名称不是输入模板的默认名称,如果使用默认名称请与当前模板匹配的默认名称}
		set Err006 {Failure:\s*The\s*profile\s*does\s*not\s*exist}
		set Err006Msg {输入模板不存在}    
		set Err007 {Failure:\s*The\s*input\s*profile\s*type\s*is\s*wrong}
		set Err007Msg {输入的模板类型错误}
		set Suc001 {config.\S+.\S+profile\S+}
		set returnPara {Err001 Err002 Err003 Err004 Err005 Err006 Err007 Suc001}
		
		

		#2. 设置目标模式(可选);
	    set mode "CfgMode" 
	  
        #3. 设置命令行
        set cmds {ont-lineprofile %OntLineProfileType% [profile-id %ProfileId%] [profile-name %ProfileName%]}
                
	    
		#5. 构建最后发送的命令的参数;
		set cmd {CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "#" ] -regexp 1 -T 10000}
		
		set ret [eval $cmd] 
		if {[string index $ret 0] == 0} {
		 set ret1 [CommonCommand -Cmds "quit" -RetList "$returnPara" -VarList "$args" -S [list "#"] -regexp 1 -T 10000]
		}
		return $ret
	
	} ;# end of proc IasOntLineProfileAdd
#===============================================================
#---------------------------测试记录----------------------------
#===============================================================



    #!!================================================================
    #  过 程 名：	IasNewModeOntTcontBindUndo
    #  函数说明：	ONT线路模板中T-CONT解绑定DBA模板ID
	#  参数说明：
	#               -TermName：      (必选)窗口名；
	#               -ProfileId:     (必选)ONT线路模板编号;
	#               -TcontId:       (必选)T-CONT编号;
	#         #     -XponMode:      (可选)默认为gpon,可以输入为epon
	#  返 回 值：
	#               错误返回错误返回值如Err001
	#  注意事项： 
	#  使用实例： 	
	#               IasNewModeOntTcontBindUndo -TermName TERM1 -ProfileId 30 -TcontId 1
	#  对应命令： 
	#               undo tcont 2 
	#	   
	#  作    者：   肖飞 00110447
	#  生成时间：   2008-8-19
	#  修改纪录：   2008-08-21 xiaofei 00110447 增加交互代码    
	#               2008-08-27 ningwenqun 00102867 修改命令下发模式内容 
	#               2008-09-17 xiaofei 00110447 增加提交数据部分
	#!!================================================================
	
	proc IasNewModeOntTcontBindUndo { args } {
	    #-----------------------------------
		#  定义私有标签码
		#-----------------------------------
		set XponMode gpon
		#--------------------------------------------
		# 定义CommonCommand的函数的各个参数
		#--------------------------------------------
		#1.返回值规则列表:
		set Suc001  {\(y/n\)\[n\]:} 
		set Err001 {Failure:\s*The\s*input\s*DBA\s*profile\s*does\s*not\s*exist}
		set Err001Msg {输入的DBA模板不存在}
		set Err002 {Failure:\s*Default\s*T\-CONT\s*can\s*not\s*be\s*unbound}
		set Err002Msg {默认T-CONT无法解除与DBA绑定关系}
		set Err003 {Failure:\s*The\s*input\s*T-CONT\s*is\s*not\s*bound\s*with\s*any\s*DBA\s*profile}
		set Err003Msg {输入的T-CONT没有绑定任何DBA模板,无需解除绑定}
		
		set returnPara {Suc001 Err001 Err002 Err003}
		
		#2.定义命令生成表达式;
		set cmds {undo tcont %TcontId%}

		#3. 设置目标模式(可选);
		CommonArgsGet $args -ProfileId ProfileId -XponMode XponMode -TermName TermName
	        set mode "ONTLINEPROFILE $XponMode $ProfileId" 
	  
	   	#4. sendPara参数，设置tsend发送命令需要的参数-s -t等;
		set Prompt  [list "#" "\(y/n\)\[n\]:"]
		
		set TimeOut 10000
		
		#5. 构建最后发送的命令的参数;
		for {set i 0} {$i < 5} {incr i} {
		  set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S $Prompt -T $TimeOut ]
		  switch -regexp -- $ret { 
		  	Suc001 {
                 set cmds {y} 
		  	} 
		  	default { 
		  		set ret2 [IasNewModeOntProfileDataCommit -TermName $TermName]
                 return $ret
            }
		  	
		  };# end of swtich
		};# end of for 
       # 6. 未知错误
       return Error
	
	} ;# end of proc  IasNewModeOntTcontBindUndo
#===============================================================
#---------------------------测试记录----------------------------
#===============================================================


#!+================================================================
#  版权(C) 2005-2012，华为技术有限公司             
#==================================================================
#                                                                  
#!!================================================================
#  过 程 名：   L2BcSetChip
#  函数说明:   配置某个vlan内所有的广播用户
#  参数说明：
#               -TermName   ：  	  (必选)窗口名；
#               -vlan：  	  ；
#				
#             
#             
#  返 回 值：  
#                执行成功；           
#					返回 0 成功码；    
#                执行失败；            
#                			返回错误码;
#  注意事项：
#  使用实例：    L2BcSetChip  -TermName $term -vlan XXX
#		    
#		   
#  对应命令：
#  
#  作    者： 
#  生成时间： 
#  修改纪录：   
#               
#!!================================================================

proc  L2BcSetChip { args } { 
	
	#-----------------------------------
	#  定义私有标签码
	#-----------------------------------
	set Suc001Msg {Command execute success!}
	set Suc001    {\s*succ\s*}
	
	set Err001Msg {Command execute error!}
	set Err001    {\s*error\s*} 

	set Err002Msg {Command execute error!}
	set Err002    {\s*(fail\.)\s*} 
	
	#--------------------------------------------
	# 定义CommonCommand的函数的各个参数
	#--------------------------------------------
	#1.返回值规则列表:
	set returnPara {Err001 Err002 Suc001}
    
	#2.定义命令生成表达式;
	set cmds {cli home/cli/chip/l2/bc_set -v vlan %vlan% fid %fid% egr %egr% valid %valid% }
	
    #3. 设置目标模式(可选);
	set mode "SDK"    
	
	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
	
	set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
	
	#根据命令行特点，退回上层模式
	set ret1 [eval AsicSdkModeChange $args] 
	
	return $ret
	
} ;# end of proc 
#=======================================================
#--------  测试记录  -----------------------------------
#=======================================================
# 


#!+================================================================
#  版权(C) 2005-2012，华为技术有限公司 综合硬件PDU            
#==================================================================
#                                                                  
#!!================================================================
#  过 程 名：   func_qos_presch_create
#  函数说明:     qos  presch_create
#  参数说明：
#               -TermName   ：  	  (必选)窗口名；
#
#               -Id         ：  	  ；
#             
#             
#  返 回 值：  
#                执行成功；           
#					返回 0 成功码；    
#                执行失败；            
#                			返回错误码;
#  注意事项：   
#  使用实例：   func_qos_presch_create -TermName $term -Id XXX
#		    
#		   
#  对应命令：    
#  
#  作    者： 工具自动生成 
#  生成时间： 2015-04-13 19:12:31
#  修改纪录：   
#               
#!!================================================================

proc  func_qos_presch_create { args } { 
	
	#-----------------------------------
	#  定义私有标签码
	#-----------------------------------
	set Suc001Msg {Command execute success!}
	set Suc001    {\s*succ\s*}       
	
	set Err001Msg {Command execute error!}
	set Err001    {\s*error\s*} 
	
	set Err002Msg {Invalid param!}
	set Err002    {Invalid\s*parameter}  
	
	set Err003Msg {Parameter number too many!}
	set Err003    {Parameter\s*[\w ]*\s*many}  
	
	set Err004Msg {Invalid command!}
	set Err004    {(Invalid|Unknown|Unrecognized|Incomplete)\s*command}  
	
	set Err005Msg {param missed!}
	set Err005    {param\s*missed}  
	
	#--------------------------------------------
	# 定义CommonCommand的函数的各个参数
	#--------------------------------------------
	#1.返回值规则列表:
	set returnPara {Err001 Err002 Err003 Err004 Err005 Suc001}
    
	#2.定义命令生成表达式;
	set cmds {cli home/cli/func/qos/presch_create -v [id %id%]}
	
	#3. 设置目标模式(可选);
	set mode "SDK"  
	
	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
    
	set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
	
	return $ret
	
} ;# end of proc 
#=======================================================
#  ------  测试记录  -----------------------------------
#=======================================================
# 


#!+================================================================
#  版权(C) 2005-2012，华为技术有限公司 综合硬件PDU            
#==================================================================
#                                                                  
#!!================================================================
#  过 程 名：   QosGssaTableSet
#  函数说明:     
#  参数说明：
#               -TermName   ：  	  (必选)窗口名；
#               -index      ：  	  ；
#               -eqm_chid   ：  	  ；
#               -schrule_sel ：  	  ；
#               -input0_gnum ：  	  ；
#               -input1_gnum ：  	  ；
#               -input2_gnum ：  	  ；
#               -input3_gnum ：  	  ；
#               -input4_gnum ：  	  ；
#               -input5_gnum ：  	  ；
#               -input6_gnum ：  	  ；
#               -input7_gnum ：  	  ；
#               -input8_gnum ：  	  ；
#               -input9_gnum ：  	  ；
#               -input10_gnum ：  	  ；
#               -input11_gnum ：  	  ；
#               -input12_gnum ：  	  ；
#               -input13_gnum ：  	  ；
#               -input14_gnum ：  	  ；
#               -input15_gnum ：  	  ；
#             
#             
#  返 回 值：  
#                执行成功；           
#					返回 0 成功码；    
#                执行失败；            
#                			返回错误码;
#  注意事项：   
#  使用实例：   QosGssaTableSet -TermName $term -index XXX -eqm_chid XXX -schrule_sel XXX -input0_gnum XXX -input1_gnum XXX -input2_gnum XXX -input3_gnum XXX -input4_gnum XXX -input5_gnum XXX -input6_gnum XXX -input7_gnum XXX -input8_gnum XXX -input9_gnum XXX -input10_gnum XXX -input11_gnum XXX -input12_gnum XXX -input13_gnum XXX -input14_gnum XXX -input15_gnum XXX
#		    
#		   
#  对应命令：    
#  
#  作    者： zhangjiefeng 00196392
#  生成时间： 2014-01-24 15:38:30
#  修改纪录：   
#               
#!!================================================================
proc  QosGssaTableSet { args } {
    ##运行set aw
    set ret [eval QosGssaTableSetOrg $args] 
	if {0 != [lindex $ret 0]} {
            ::TestLib::ShowTraceMessage -level 10 -color RED -msg \
            "\"Set\" 命令执行失败，请检查！" 
	        return $ret
	};#endif
	
	upvar L2GetFlag L2GetFlagDef
	catch {set L2GetFlag $L2GetFlagDef} msg
	
    CommonArgsGet $args -TermName termName -L2GetFlag L2GetFlag
	if {[info exists L2GetFlag] && ("on" == $L2GetFlag)} {
	
	    ::TestLib::ShowTraceMessage -level 10 -color BLUE -msg \
        "对比测试Get命令行返回值！" 
	            
	    # 获取并组合匹配项
	    set cmpRet ""
	    set getParam ""
	    # 函数参数列表
	    set mapRet {index eqm_chid schrule_sel input0_gnum input1_gnum input2_gnum input3_gnum input4_gnum input5_gnum input6_gnum input7_gnum input8_gnum input9_gnum input10_gnum input11_gnum input12_gnum input13_gnum input14_gnum input15_gnum }
	    # 格式为16进制参数
	    set x_Ret ""
	    # 格式为10进制参数
	    set d_Ret "index eqm_chid schrule_sel input0_gnum input1_gnum input2_gnum input3_gnum input4_gnum input5_gnum input6_gnum input7_gnum input8_gnum input9_gnum input10_gnum input11_gnum input12_gnum input13_gnum input14_gnum input15_gnum"
	    # 格式为字符串
	    set str_Ret ""
	    # get需调用参数
	    set output_Ret "index"
        
        #组合get所用参数
        foreach j $output_Ret {
        	
        	set cmpDef [regexp -inline -all -- "\-$j\\s\+\(\\S\+\)" $args]
        	set cmpCount [lindex $cmpDef 0]
        	set cmpC [lindex $cmpDef 1]
        	
        	# 格式转换
        	if {(-1 != [lsearch $x_Ret $j]) && ("" != $cmpC)} {
                set getParam [concat $getParam -$j 0x[format %x $cmpC] ]
        	} elseif {(-1 != [lsearch $d_Ret $j]) && ("" != $cmpC)} {
                set getParam [concat $getParam -$j [format %d $cmpC] ]
        	} elseif {(-1 != [lsearch $str_Ret $j]) && ("" != $cmpC)} {
                set getParam [concat $getParam -$j $cmpC ]
        	} else {
                set getParam [concat $getParam $cmpCount]
        	};#endelseif
        	
        };#endforeach 
        
        #组合cmp所用参数
        foreach j $mapRet {
        	
        	set cmpDef [regexp -inline -all -- "\-$j\\s\+\(\\S\+\)" $args]
        	set cmpCount [lindex $cmpDef 0]
        	set cmpC [lindex $cmpDef 1]
        	
        	# 格式转换
        	if {(-1 != [lsearch $x_Ret $j]) && ("" != $cmpC)} {
                set cmpRet [concat $cmpRet -$j 0x[format %x $cmpC] ]
        	} elseif {(-1 != [lsearch $d_Ret $j]) && ("" != $cmpC)} {
                set cmpRet [concat $cmpRet -$j [format %d $cmpC] ]
        	} elseif {(-1 != [lsearch $str_Ret $j]) && ("" != $cmpC)} {
                set cmpRet [concat $cmpRet -$j $cmpC ]
        	} else {
                set cmpRet [concat $cmpRet $cmpCount]
        	};#endelseif
        	        	
        };#endforeach
        puts "cmpRet==$cmpRet getParam==$getParam"
        
        set ret [eval QosGssaTableGetOrg -TermName $termName $getParam -CmpList {$cmpRet}]
	    # 判断 get 是否成功;
	    if {0 != [lindex $ret 0]} {
            ::TestLib::ShowTraceMessage -level 10 -color RED -msg \
            "\"Set\" 之后 \"Get\" 返回值不匹配，请检查！返回值为：$ret" 
	        return $ret
	    };#endif	    
	};#endif
	
	return $ret
}

proc  QosGssaTableGetOrg { args } { 
	
	#-----------------------------------
	#  定义私有标签码
	#-----------------------------------
	set Suc001Msg   {Command execute success!}
	set Suc001     	{index\s*:\s*([0-9]+).*schrule_sel\s*:\s*(\w+).*eqm_chid\s*:\s*([0-9]+).*input0_gnum\s*:\s*([0-9]+).*input1_gnum\s*:\s*([0-9]+).*input2_gnum\s*:\s*([0-9]+).*input3_gnum\s*:\s*([0-9]+).*input4_gnum\s*:\s*([0-9]+).*input5_gnum\s*:\s*([0-9]+).*input6_gnum\s*:\s*([0-9]+).*input7_gnum\s*:\s*([0-9]+).*input8_gnum\s*:\s*([0-9]+).*input9_gnum\s*:\s*([0-9]+).*input10_gnum\s*:\s*([0-9]+).*input11_gnum\s*:\s*([0-9]+).*input12_gnum\s*:\s*([0-9]+).*input13_gnum\s*:\s*([0-9]+).*input14_gnum\s*:\s*([0-9]+).*input15_gnum\s*:\s*([0-9]+)}
    set Suc001Ret   {index  schrule_sel eqm_chid input0_gnum input1_gnum input2_gnum input3_gnum input4_gnum input5_gnum input6_gnum input7_gnum input8_gnum input9_gnum input10_gnum input11_gnum input12_gnum input13_gnum input14_gnum input15_gnum }
	
	set Suc002Msg {Command execute success!}
	set Suc002    {\s*succ\s*}
	
	set Err001Msg {Command execute error!}
	set Err001    {\s*error\s*} 

	set Err002Msg {Command execute error!}
	set Err002    {\s*(fail\.)\s*} 
	
	#--------------------------------------------
	# 定义CommonCommand的函数的各个参数
	#--------------------------------------------
	#1.返回值规则列表:
	set returnPara {Err001 Err002 Suc001 Suc002 }
    
	#2.定义命令生成表达式;
	#set cmds {cli /home/cli/chip_ext/qos_gssa_table_get -v index %index%} 
	set cmds {cli /home/cli/chip/eqm/eqm_gssa_gen_sch_attr_get  -v index %index%}

	#3. 设置目标模式(可选);
	set mode "SDK"    
	
	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
	
	set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 

	#--------------------------------------------
	# 匹配返回值
	#--------------------------------------------
	set  cmpList ""
	CommonArgsGet $args -CmpList cmpList

	#检查返回值，如果匹配信息直接返回ret
	if {0 != [lindex $ret 0] || "" == $cmpList } {
		return $ret
	}
	#根据用户输入的值与返回值进行匹配	
	set cmpVar \{\{[lrange $ret 2 end]\}\}
	
	if {0 == [CommonRegexpMatchMult $cmpList cmpVar]} {
		return "0 Suc020 $ret"

	} else {
		return Err020 

	} ; #end if
	
	return $ret
		
} ;# end of proc 

proc  QosGssaTableSetOrg { args } { 
	
	#-----------------------------------
	#  定义私有标签码
	#-----------------------------------
	set Suc001Msg {Command execute success!}
	set Suc001    {\s*succ\s*}
	
	set Err001Msg {Command execute error!}
	set Err001    {\s*error\s*} 

	set Err002Msg {Command execute error!}
	set Err002    {\s*fail\s*} 
		
	#--------------------------------------------
	# 定义CommonCommand的函数的各个参数
	#--------------------------------------------
	#1.返回值规则列表:
	set returnPara {Err001 Err002 Suc001}
    
	#2.定义命令生成表达式;
	#set cmds {cli /home/cli/chip_ext/qos_gssa_table_set -v [index %index%] [eqm_chid %eqm_chid%] [schrule_sel %schrule_sel%] [input0_gnum %input0_gnum%] [input1_gnum %input1_gnum%] [input2_gnum %input2_gnum%] [input3_gnum %input3_gnum%] [input4_gnum %input4_gnum%] [input5_gnum %input5_gnum%] [input6_gnum %input6_gnum%] [input7_gnum %input7_gnum%] [input8_gnum %input8_gnum%] [input9_gnum %input9_gnum%] [input10_gnum %input10_gnum%] [input11_gnum %input11_gnum%] [input12_gnum %input12_gnum%] [input13_gnum %input13_gnum%] [input14_gnum %input14_gnum%] [input15_gnum %input15_gnum%]}
	set cmds {cli /home/cli/chip/eqm/eqm_gssa_gen_sch_attr_set -v [index %index%] [eqm_chid %eqm_chid%] [schrule_sel %schrule_sel%] [input0_gnum %input0_gnum%] [input1_gnum %input1_gnum%] [input2_gnum %input2_gnum%] [input3_gnum %input3_gnum%] [input4_gnum %input4_gnum%] [input5_gnum %input5_gnum%] [input6_gnum %input6_gnum%] [input7_gnum %input7_gnum%] [input8_gnum %input8_gnum%] [input9_gnum %input9_gnum%] [input10_gnum %input10_gnum%] [input11_gnum %input11_gnum%] [input12_gnum %input12_gnum%] [input13_gnum %input13_gnum%] [input14_gnum %input14_gnum%] [input15_gnum %input15_gnum%]}

	#3. 设置目标模式(可选);
	set mode "SDK"  
	
	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
    
	set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
	
	return $ret
	
} ;# end of proc 
#=======================================================
#  ------  测试记录  -----------------------------------
#=======================================================
# 


#!+================================================================
#  版权(C) 2005-2012，华为技术有限公司 综合硬件PDU            
#==================================================================
#                                                                  
#!!================================================================
#  过 程 名：   QosShtTableSet
#  函数说明:     
#  参数说明：
#               -TermName   ：  	  (必选)窗口名；
#               -index      ：  	  ；
#               -xir        ：  	  ；
#               -xbs        ：  	  ；
#               -shape_mode ：  	  ；
#             
#             
#  返 回 值：  
#                执行成功；           
#					返回 0 成功码；    
#                执行失败；            
#                			返回错误码;
#  注意事项：   
#  使用实例：   QosShtTableSet -TermName $term -index XXX -xir XXX -xbs XXX -shape_mode XXX
#		    
#		   
#  对应命令：    
#  
#  作    者： zhangjiefeng 00196392
#  生成时间： 2014-01-24 15:38:30
#  修改纪录：   
#               
#!!================================================================
proc  QosShtTableSet { args } {
    ##运行set aw
    set ret [eval QosShtTableSetOrg $args] 
	if {0 != [lindex $ret 0]} {
            ::TestLib::ShowTraceMessage -level 10 -color RED -msg \
            "\"Set\" 命令执行失败，请检查！" 
	        return $ret
	};#endif
	
	upvar L2GetFlag L2GetFlagDef
	catch {set L2GetFlag $L2GetFlagDef} msg
	
    CommonArgsGet $args -TermName termName -L2GetFlag L2GetFlag
	if {[info exists L2GetFlag] && ("on" == $L2GetFlag)} {
	
	    ::TestLib::ShowTraceMessage -level 10 -color BLUE -msg \
        "对比测试Get命令行返回值！" 
	            
	    # 获取并组合匹配项
	    set cmpRet ""
	    set getParam ""
	    # 函数参数列表
	    set mapRet {index  shape_mode xir xbs }
	    # 格式为16进制参数
	    set x_Ret ""
	    # 格式为10进制参数
	    set d_Ret "index shape_mode xir xbs "
	    # 格式为字符串
	    set str_Ret ""
	    # get需调用参数
	    set output_Ret "index"
        
        #组合get所用参数
        foreach j $output_Ret {
        	
        	set cmpDef [regexp -inline -all -- "\-$j\\s\+\(\\S\+\)" $args]
        	set cmpCount [lindex $cmpDef 0]
        	set cmpC [lindex $cmpDef 1]
        	
        	# 格式转换
        	if {(-1 != [lsearch $x_Ret $j]) && ("" != $cmpC)} {
                set getParam [concat $getParam -$j 0x[format %x $cmpC] ]
        	} elseif {(-1 != [lsearch $d_Ret $j]) && ("" != $cmpC)} {
                set getParam [concat $getParam -$j [format %d $cmpC] ]
        	} elseif {(-1 != [lsearch $str_Ret $j]) && ("" != $cmpC)} {
                set getParam [concat $getParam -$j $cmpC ]
        	} else {
                set getParam [concat $getParam $cmpCount]
        	};#endelseif
        	
        };#endforeach 
        
        #组合cmp所用参数
        foreach j $mapRet {
        	
        	set cmpDef [regexp -inline -all -- "\-$j\\s\+\(\\S\+\)" $args]
        	set cmpCount [lindex $cmpDef 0]
        	set cmpC [lindex $cmpDef 1]
        	
        	# 格式转换
        	if {(-1 != [lsearch $x_Ret $j]) && ("" != $cmpC)} {
                set cmpRet [concat $cmpRet -$j 0x[format %x $cmpC] ]
        	} elseif {(-1 != [lsearch $d_Ret $j]) && ("" != $cmpC)} {
                set cmpRet [concat $cmpRet -$j [format %d $cmpC] ]
        	} elseif {(-1 != [lsearch $str_Ret $j]) && ("" != $cmpC)} {
                set cmpRet [concat $cmpRet -$j $cmpC ]
        	} else {
                set cmpRet [concat $cmpRet $cmpCount]
        	};#endelseif
        	        	
        };#endforeach
        puts "cmpRet==$cmpRet getParam==$getParam"
        
       set ret [eval QosShtTableGetOrg -TermName $termName $getParam -CmpList {$cmpRet}]
	    # 判断 get 是否成功;
	    if {0 != [lindex $ret 0]} {
            ::TestLib::ShowTraceMessage -level 10 -color RED -msg \
            "\"Set\" 之后 \"Get\" 返回值不匹配，请检查！返回值为：$ret" 
	        return $ret
	    };#endif	    
	};#endif
	
	return $ret
}

proc  QosShtTableGetOrg { args } { 
	
	#-----------------------------------
	#  定义私有标签码
	#-----------------------------------
	set Suc001Msg  {Command execute success!}
	set Suc001     {index\s*:\s*([0-9]+).*shape_mode\s*:\s*([0-9]+).*xir\s*:\s*([0-9]+).*xbs\s*:\s*([0-9]+)}
    set Suc001Ret  {index shape_mode xir xbs  }
	
	set Suc002Msg {Command execute success!}
	set Suc002    {\s*succ\s*}
	
	set Err001Msg {Command execute error!}
	set Err001    {\s*error\s*} 

	set Err002Msg {Command execute error!}
	set Err002    {\s*(fail\.)\s*} 
	
	#--------------------------------------------
	# 定义CommonCommand的函数的各个参数
	#--------------------------------------------
	#1.返回值规则列表:
	set returnPara {Err001 Err002 Suc001 Suc002 }
    
	#2.定义命令生成表达式;
	#set cmds {cli /home/cli/chip_ext/qos_sht_table_get -v index %index%}
    set cmds {cli /home/cli/chip/eqm/eqm_sht_shaper_profile_get -v index %index%}
                  
	#3. 设置目标模式(可选);
	set mode "SDK"    
	
	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
	
	set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 

	#--------------------------------------------
	# 匹配返回值
	#--------------------------------------------
	set  cmpList ""
	CommonArgsGet $args -CmpList cmpList

	#检查返回值，如果匹配信息直接返回ret
	if {0 != [lindex $ret 0] || "" == $cmpList } {
		return $ret
	}
	#根据用户输入的值与返回值进行匹配	
	set cmpVar \{\{[lrange $ret 2 end]\}\}
	puts "cmpList=$cmpList"
	puts "cmpVar=$cmpVar"
	if {0 == [CommonRegexpMatchMult $cmpList cmpVar]} {
		return "0 Suc020 $ret"

	} else {
		return Err020 

	} ; #end if
	
	return $ret
		
} ;# end of proc 

proc  QosShtTableSetOrg { args } { 
	puts "==QosShtTableSetOrg==$args"
	#-----------------------------------
	#  定义私有标签码
	#-----------------------------------
	set Suc001Msg {Command execute success!}
	set Suc001    {\s*succ\s*}
	
	set Err001Msg {Command execute error!}
	set Err001    {\s*error\s*} 

	set Err002Msg {Command execute error!}
	set Err002    {\s*fail\s*} 
		
	#--------------------------------------------
	# 定义CommonCommand的函数的各个参数
	#--------------------------------------------
	#1.返回值规则列表:
	set returnPara {Err001 Err002 Suc001}
    
	#2.定义命令生成表达式;
	#set cmds {cli /home/cli/chip_ext/qos_sht_table_set -v [index %index%] [xir %xir%] [xbs %xbs%] [shape_mode %shape_mode%]}
	set cmds  {cli /home/cli/chip/eqm/eqm_sht_shaper_profile_set -v [index %index%] [xir %xir%] [xbs %xbs%] [shape_mode %shape_mode%]}

	::TestLib::ShowTraceMessage -level 10 -color BLUE -msg "QosShtTableSet -> QosShtTableSetOrg 执行命令行 cli  /home/cli/chip_ext/qos_sht_table_set -v $args 成功"
	
	#3. 设置目标模式(可选);
	set mode "SDK"  
	
	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
    
	set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
	
	return $ret
	
} ;# end of proc 
#=======================================================
#  ------  测试记录  -----------------------------------
#=======================================================
# 


#!+================================================================
#  版权(C) 2005-2012，华为技术有限公司 综合硬件PDU            
#==================================================================
#                                                                  
#!!================================================================
#  过 程 名：   QosSsctTableSet
#  函数说明:     
#  参数说明：
#               -TermName   ：  	  (必选)窗口名；
#               -index      ：  	  ；
#               -pir_shp_mnum ：  	  ；
#               -sshp_mode  ：  	  ；
#               -pir_tk_byte ：  	  ；
#               -pir_shp_borr_st ：  	  ；
#             
#             
#  返 回 值：  
#                执行成功；           
#					返回 0 成功码；    
#                执行失败；            
#                			返回错误码;
#  注意事项：   
#  使用实例：   QosSsctTableSet -TermName $term -index XXX -pir_shp_mnum XXX -sshp_mode XXX -pir_tk_byte XXX -pir_shp_borr_st XXX
#		    
#		   
#  对应命令：    
#  
#  作    者： zhangjiefeng 00196392
#  生成时间： 2014-01-24 15:38:30
#  修改纪录：   
#               
#!!================================================================
proc  QosSsctTableSet { args } {
    ##运行set aw  
    set sshp_mode 0 
    CommonArgsGet $args  -sshp_mode sshp_mode -pir_shp_mnum pir_shp_mnum
    #原来命令行支持sshp_mode值为1、0，当前为bps、pps
    switch $sshp_mode {
    	0 {set mode bps}
    	1 {set mode pps}
    	default {set mode bps}
    };#endswitch
    
    #参数名称发生变化，进行转换
    set args [CommonArgsSet $args -sht_idx $pir_shp_mnum -mode $mode]
    CommonArgsDel args -pshp_mode -pir_shp_borr_s
    
    set ret [eval QosSsctTableSetOrg $args] 
	if {0 != [lindex $ret 0]} {
            ::TestLib::ShowTraceMessage -level 10 -color RED -msg \
            "\"Set\" 命令执行失败，请检查！" 
	        return $ret
	};#endif
	
	upvar L2GetFlag L2GetFlagDef
	catch {set L2GetFlag $L2GetFlagDef} msg
	
    CommonArgsGet $args -TermName termName -L2GetFlag L2GetFlag
	if {[info exists L2GetFlag] && ("on" == $L2GetFlag)} {
	
	    ::TestLib::ShowTraceMessage -level 10 -color BLUE -msg \
        "对比测试Get命令行返回值！" 
	            
	    # 获取并组合匹配项
	    set cmpRet ""
	    set getParam ""
	    # 函数参数列表
	    set mapRet {index sht_idx   }
	    # 格式为16进制参数
	    set x_Ret ""
	    # 格式为10进制参数
	    set d_Ret "index sht_idx   "
	    # 格式为字符串
	    set str_Ret ""
	    # get需调用参数
	    set output_Ret "index"
        
        #组合get所用参数
        foreach j $output_Ret {
        	
        	set cmpDef [regexp -inline -all -- "\-$j\\s\+\(\\S\+\)" $args]
        	set cmpCount [lindex $cmpDef 0]
        	set cmpC [lindex $cmpDef 1]
        	
        	# 格式转换
        	if {(-1 != [lsearch $x_Ret $j]) && ("" != $cmpC)} {
                set getParam [concat $getParam -$j 0x[format %x $cmpC] ]
        	} elseif {(-1 != [lsearch $d_Ret $j]) && ("" != $cmpC)} {
                set getParam [concat $getParam -$j [format %d $cmpC] ]
        	} elseif {(-1 != [lsearch $str_Ret $j]) && ("" != $cmpC)} {
                set getParam [concat $getParam -$j $cmpC ]
        	} else {
                set getParam [concat $getParam $cmpCount]
        	};#endelseif
        	
        };#endforeach 
        
        #组合cmp所用参数
        foreach j $mapRet {
        	
        	set cmpDef [regexp -inline -all -- "\-$j\\s\+\(\\S\+\)" $args]
        	set cmpCount [lindex $cmpDef 0]
        	set cmpC [lindex $cmpDef 1]
        	
        	# 格式转换
        	if {(-1 != [lsearch $x_Ret $j]) && ("" != $cmpC)} {
                set cmpRet [concat $cmpRet -$j 0x[format %x $cmpC] ]
        	} elseif {(-1 != [lsearch $d_Ret $j]) && ("" != $cmpC)} {
                set cmpRet [concat $cmpRet -$j [format %d $cmpC] ]
        	} elseif {(-1 != [lsearch $str_Ret $j]) && ("" != $cmpC)} {
                set cmpRet [concat $cmpRet -$j $cmpC ]
        	} else {
                set cmpRet [concat $cmpRet $cmpCount]
        	};#endelseif
        	        	
        };#endforeach
        puts "cmpRet==$cmpRet getParam==$getParam"
        
        set ret [eval QosSsctTableGetOrg -TermName $termName $getParam -CmpList {$cmpRet}]
	    # 判断 get 是否成功;
	    if {0 != [lindex $ret 0]} {
            ::TestLib::ShowTraceMessage -level 10 -color RED -msg \
            "\"Set\" 之后 \"Get\" 返回值不匹配，请检查！返回值为：$ret" 
	        return $ret
	    };#endif	    
	};#endif
	
	return $ret
}

proc  QosSsctTableGetOrg { args } { 
	
	#-----------------------------------
	#  定义私有标签码
	#-----------------------------------
	set Suc001Msg  {Command execute success!}
	set Suc001     {index\s*:\s*([0-9]+).*mode\s*:\s*(\w+).*sht_idx\s*:\s*([0-9]+).*borr_st\s*:\s*(\w+).*pri_tk_byte\s*:\s*([0-9]+).*gadj_tk_byte\s*:\s*([0-9]+)}
    set Suc001Ret  {index mode sht_idx borr_st pri_tk_byte gadj_tk_byte  }
	
	set Suc002Msg {Command execute success!}
	set Suc002    {\s*succ\s*}
	
	set Err001Msg {Command execute error!}
	set Err001    {\s*error\s*} 

	set Err002Msg {Command execute error!}
	set Err002    {\s*(fail\.)\s*} 
	
	#--------------------------------------------
	# 定义CommonCommand的函数的各个参数
	#--------------------------------------------
	#1.返回值规则列表:
	set returnPara {Err001 Err002 Suc001 Suc002 }
    
	#2.定义命令生成表达式;
	#set cmds {cli /home/cli/chip_ext/qos_ssct_table_get -v index %index% }
   	set cmds {cli /home/cli/chip/eqm/eqm_ssct_gen_sch_bind_shaper_profile_get -v index %index% }
                   
	#3. 设置目标模式(可选);
	set mode "SDK"    
	
	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
	
	set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 

	#--------------------------------------------
	# 匹配返回值
	#--------------------------------------------
	set  cmpList ""
	CommonArgsGet $args -CmpList cmpList

	#检查返回值，如果匹配信息直接返回ret
	if {0 != [lindex $ret 0] || "" == $cmpList } {
		return $ret
	}
	#根据用户输入的值与返回值进行匹配	
	set cmpVar \{\{[lrange $ret 2 end]\}\}
	
	if {0 == [CommonRegexpMatchMult $cmpList cmpVar]} {
		return "0 Suc020 $ret"

	} else {
		return Err020 

	} ; #end if
	
	return $ret
		
} ;# end of proc 

proc  QosSsctTableSetOrg { args } { 
	
	#-----------------------------------
	#  定义私有标签码
	#-----------------------------------
	set Suc001Msg {Command execute success!}
	set Suc001    {\s*succ\s*}
	
	set Err001Msg {Command execute error!}
	set Err001    {\s*error\s*} 

	set Err002Msg {Command execute error!}
	set Err002    {\s*fail\s*} 
		
	#--------------------------------------------
	# 定义CommonCommand的函数的各个参数
	#--------------------------------------------
	#1.返回值规则列表:
	set returnPara {Err001 Err002 Suc001}
    
	#2.定义命令生成表达式;
	#set cmds {cli /home/cli/chip_ext/qos_ssct_table_set -v [index %index%] [pir_shp_mnum %pir_shp_mnum%] [sshp_mode %sshp_mode%] [pir_tk_byte %pir_tk_byte%] [pir_shp_borr_st %pir_shp_borr_st%]}
	set cmds {cli /home/cli/chip/eqm/eqm_ssct_gen_sch_bind_shaper_profile_set -v [index %index%] [sht_idx %sht_idx%] [mode %mode%] [pri_tk_byte %pri_tk_byte%] [borr_st %borr_st%]}

	#3. 设置目标模式(可选);
	set mode "SDK"  
	
	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
    
	set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
	
	return $ret
	
} ;# end of proc 
#=======================================================
#  ------  测试记录  -----------------------------------
#=======================================================
# 


#!+================================================================
#  版权(C) 2005-2012，华为技术有限公司 综合硬件PDU            
#==================================================================
#                                                                  
#!!================================================================
#  过 程 名：   GponMapSfcSet
#  函数说明:     GPON上行SFC映射表设置
#  参数说明：
#               -TermName   ：  	  (必选)窗口名；
#               -sfc_id     ：  	  ；
#               -gemport    ：  	  ；
#               -tcont      ：  	  ；
#               -car_en     ：  	  ；
#               -car_id     ：  	  ；
#               -pri_mark_en ：  	  ；
#               -pri        ：  	  ；
#               -pre_sch_en ：  	  ；
#               -qid0       ：  	  ；
#               -qid1       ：  	  ；
#               -qid2       ：  	  ；
#               -qid3       ：  	  ；
#               -qid4       ：  	  ；
#               -qid5       ：  	  ；
#               -qid6       ：  	  ；
#               -qid7       ：  	  ；
#             
#             
#  返 回 值：  
#                执行成功；           
#					返回 0 成功码；    
#                执行失败；            
#                			返回错误码;
#  注意事项：   
#  使用实例：   GponMapSfcSet -TermName $term -sfc_id XXX -gemport XXX -tcont XXX -car_en XXX -car_id XXX -pri_mark_en XXX -pri XXX -pre_sch_en XXX -qid0 XXX -qid1 XXX -qid2 XXX -qid3 XXX -qid4 XXX -qid5 XXX -qid6 XXX -qid7 XXX
#		    
#		   
#  对应命令：    
#  
#  作    者： zhangna 00102865 
#  生成时间： 2014-02-08 17:07:58
#  修改纪录：   
#               
#!!================================================================

proc  GponMapSfcSet { args } { 
	
	#-----------------------------------
	#  定义私有标签码
	#-----------------------------------
	set Suc001Msg {Command execute success!}
	set Suc001    {\s*succ\s*}
	
	set Err001Msg {Command execute error!}
	set Err001    {\s*error\s*} 

	set Err002Msg {Command execute error!}
	set Err002    {\s*fail\s*} 
		
	#--------------------------------------------
	# 定义CommonCommand的函数的各个参数
	#--------------------------------------------
	#1.返回值规则列表:
	set returnPara {Err001 Err002 Suc001}
    
	#2.定义命令生成表达式;
	#set cmds {cli /home/cli/hal_ext/gpon_map_set -v [sfc_id %sfc_id%] [gemport %gemport%] [tcont %tcont%] [car_en %car_en%] [car_id %car_id%] \
	#	[pri_mark_en %pri_mark_en%] [pri %pri%] [pre_sch_en %pre_sch_en%] [qid0 %qid0%] [qid1 %qid1%] [qid2 %qid2%] [qid3 %qid3%] [qid4 %qid4%] [qid5 %qid5%] [qid6 %qid6%] [qid7 %qid7%]}
#	set cmds0 {cli /home/cli/api/gpon/gemport_map_del -v [mapid %sfc_id%]}
#	set cmds1 {cli /home/cli/api/gpon/gemport_map_set -v [mapid %sfc_id%] [gemport %gemport%] [port %port%] [mask %mask%] [level %level%] \
#		[vlanmode %vlanmode%] [vlan %vlan%] [primode %primode%] [pri %pri%] [iptosmode %iptosmode%] [iptos %iptos%] [bridgeid %bridgeid%]}
#	set cmds2 {cli /home/cli/api/gpon/gemport_map_car_set -v [carid %car_id%] [cir %cir%] [pir %pir%] [cbs %cbs%] [pbs %pbs%] [coloraware %color_aware%]} 
#	set cmds3 {cli /home/cli/api/gpon/gemport_map_car_connect -v [mapid %sfc_id%] [carid %car_id%]}
	set cmds  {cli /home/cli/func/pon/map_set -v [sfcid %sfc_id%] [gemport %gemport%] [tcont %tcont%] [car_en %car_en%] [car_id %car_id%] \
		[point_pri_en %pri_mark_en%] [point_pri %pri%] [pre_sch_en %pre_sch_en%] [pre_sch %pre_sch%] [valid %valid%]} 
	
	#3. 设置目标模式(可选);
	set mode "SDK"  
	
	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
    
    set ret [CommonCommand -Cmds "$cmds" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
#	set ret [CommonCommand -Cmds "$cmds0" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
#	
#	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
    
#	set ret [CommonCommand -Cmds "$cmds1" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000]
#	
#	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
#    
#	set ret [CommonCommand -Cmds "$cmds2" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000]
#	
#	set ret [CommonCommand -Cmds "\n" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000] 
#    
#	set ret [CommonCommand -Cmds "$cmds3" -RetList "$returnPara" -Mode "$mode" -VarList "$args" -S [list "\(y/n\)\[n\]:" "#" ">"] -T 20000]
	
	return $ret
	
} ;# end of proc 
#=======================================================
#  ------  测试记录  -----------------------------------
#=======================================================
# 



#!!================================================================
#  过 程 名：   QosCheckNoFullStremMixData
#  函数说明:   核对某条流的 rx_line_bps 和 另外一条流的 rx_pps 数据
#  参数说明：
#               -streamSum ：  	  流个数
#               -sampleTimes ：    采样次数
#               -pktLenList ：  	  报文长度列表
#               -allowError ：	  允许误差值
#               -statItem ：  	  采样度量项
#               -statIteStopStream ： 停流后采样度量项
#               -forward ： 	 预期值
#               -checkType   核对类型：pps、bps
#               -bpsType     是否精确匹配
#             
#  返 回 值：  
#                执行成功；           
#					返回 0 成功码；    
#                执行失败；            
#                	返回错误码;
#  注意事项：
#  使用实例：
#		    
#		   
#  对应命令： 
#  
#  作    者： dengwenxian dwx5315511
#  生成时间： 2014-9-19 15:34:32
#  修改纪录：   
#               
#!!================================================================
proc  QosCheckNoFullStremMixData { args } { 
    
    puts "==QosCheckNoFullStremMixData==$args"
	#测试仪参数
	set sendPort    	0 ; #测试仪发送端口
	set staPort       	0 ; #测试仪接收端口

	#其他变量
	set tsuID			1 ; #测试仪ID
	set sampleTimes		1 ;  #采样次数
	set allowError      0.01;#默认误差
    set speedPercent    100;#默认满端口发送
    set bpsType         "EXACT";# rx_line_bps 是否精确匹配
    set rateMode        Percentage ; #测试仪发送速率模式，默认是百分比
    set retFlag         "TRUE"      ; #返回类型
    set inVlan          "FALSE"      ; #内部vlan
    set inPri           "FALSE"       ;#内部优先级
#    set repeatCount     {1 1 1 1 1 1 1 1} ; #重复次数
    set payLoad         "PRBS"            ; # payload 模式
    set oltSvlanId      560               ; #背景流的vlan
    set blackStreamFlg  "FALSE"           ; #是否有背景流
    set streamLoad      "FALSE" ; #指定每条流的流量大小，单位是Kbps
    
    set bpsFlag         "FALSE" ; #PPS 的时候，是否累计发送流的rx_line_bps
    set streamPick      {1 0 1 1 0 1 1 1} ;#PPS 的时候，是否累计发送流的rx_line_bps.  为 1表示要累计该条流，为 0 表示不累计该条流
    set forwardTotalBps "FALSE"
    set temp_CreatStreamList "FALSE"
    set sentWaitTime    3  ; #采样前持续发包时间;
    set fitteryType "TRUE" ; #是否要计算抖动值
    set doubleSteam "FALSE" ; #是否要进行双向发流。每条单向流都复制一条对发的流，仅流名称、SMac、DMac等三个参数不同。
    set sendType    "SINGLE"; #单向发流
    set staPortSpeed 80.0 ;#双向发流时，对端口的端口速率
    set doubleSteamVlan {234234 234234 } ;
    set dIp "FALSE"
    set sIp "FALSE"
    
	#获取传入参数
	CommonArgsGet $args -TermName termName -TsuID tsuID \
	                    -StreamSum streamSum -Speed speedPercent -RateMode rateMode \
	                    -SendPort sendPort -StaPort staPort \
	                    -StatMode statMode -Vlan vlanID -Pri pri -SMac sMac -DMac dMac \
	                    -SampleTimes sampleTimes -PktLenList pktLenList \
	                    -SaveCfgFile saveCfgtoFile -StaItem statItem \
						-StatIteStopStream statIteStopStream \
						-AllowError allowError \
                        -RepeatCount repeatCount \
                        -InnerVlan inVlan \
                        -InPri inPri \
                        -PayLoad  payLoad \
                        -OltSvlanId oltSvlanId \
                        -BlackStreamFlg blackStreamFlg \
                        -ForwardMix forwardMix \
                        -ForwardTotalBps forwardTotalBps \
                        -StreamLoad streamLoad \
                        -SentWaitTime sentWaitTime \
                        -FitteryType fitteryType \
                        -AllowErrorFittery allowErrorFittery \
                        -ForwardPktNum forwardPktNum \
                        -DoubleSteam doubleSteam \
                        -DoubleSteamVlan doubleSteamVlan \
                        -SendType sendType \
                        -StaPortSpeed staPortSpeed \
                        -DIp dIp -SIp sIp
                        
    set allowErrorBackUp $allowError
    
    
    set lenList_length [ llength $pktLenList ]
    puts "lenList_length:$lenList_length"
    
    for {set k 0} {$k < $lenList_length} {incr k 1} {
        set pktLen [lindex $pktLenList $k]

        ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(QosCheckNoFullStremMixData0020), ======包长为 $pktLen =============="
        set length  [ llength $pktLen  ]
        set pktLenT [ lindex $pktLen 0 ] 
        
	    #构建报文参数:
		set temp_CreatStreamList [ QosCreatStreamList -TsuID $tsuID -StreamSum $streamSum \
		                    -Speed $speedPercent -RateMode $rateMode \
		                    -SendPort $sendPort -StaPort $staPort -StatMode $statMode -Vlan $vlanID \
		                    -Pri $pri -SMac $sMac -DMac $dMac \
		                    -PktLen $pktLen -InnerVlan $inVlan -InPri $inPri -PayLoad  $payLoad \
		                    -StreamLoad $streamLoad -DIp $dIp -SIp $sIp]
        
        puts "temp_CreatStreamList:$temp_CreatStreamList"
        

	    #往测试队列发送报文，不停流. 但，要判断是否有参数 repeatCount dengwenxian  20141117
		if {([info exists repeatCount])} { 
	        QosCreatAndSendStremNoStop -StaItem $statItem -SendElement $temp_CreatStreamList \
	                               -SaveCfgFile $saveCfgtoFile -SentWaitTime $sentWaitTime \
	                               -OltSvlanId $oltSvlanId -BlackStreamFlg $blackStreamFlg \
	                               -DoubleSteam $doubleSteam -StaPortSpeed $staPortSpeed \
	                               -DoubleSteamVlan $doubleSteamVlan \
	                               -RepeatCount $repeatCount
		} else {
	        QosCreatAndSendStremNoStop -StaItem $statItem -SendElement $temp_CreatStreamList \
	                               -SaveCfgFile $saveCfgtoFile -SentWaitTime $sentWaitTime \
	                               -OltSvlanId $oltSvlanId -BlackStreamFlg $blackStreamFlg \
	                               -DoubleSteam $doubleSteam -StaPortSpeed $staPortSpeed \
	                               -DoubleSteamVlan $doubleSteamVlan
		} ;# end if
		
		IasCommonDelay -Time 3
	    #多次采样报文:
	    set temp_GetStreamData [ QosGetStreamData -StreamSum $streamSum -SampleTimes $sampleTimes \
	                                 -SendElement $temp_CreatStreamList -PktLen $pktLen \
	                                 -OltSvlanId $oltSvlanId -BlackStreamFlg $blackStreamFlg \
	                                 -FitteryType $fitteryType -DoubleSteam $doubleSteam \
	                                 -SendType $sendType ]

        puts "temp_GetStreamData:$temp_GetStreamData"
        
        #停流:
        set returnPktNum [ QosStopAndResume -StaItem $statIteStopStream -SendElement $temp_CreatStreamList ]
        
	    #判断是否有 RX_PAYLOAD_ERRORS 错误 
	    if {"0" == [lindex $returnPktNum 0 ]} {
	       
	       ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(QosCheckNoFullStremMixData0025), \
	           开始判断是否有 RX_PAYLOAD_ERRORS 错误，有错直接报错，退出！详细信息可以查看上面的 QosPortStopAndResume START 打印 ！"
	       CommonArgsGet $returnPktNum -retStat retStat
	       ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(QosCheckNoFullStremMixData0026), retStat:$retStat"
	       set retStatSum [ llength $retStat ]
	       
#	       #循环处理所有流
#	       for {set j 0} { $j < $retStatSum } { incr j 1} {
#	          set retStatTemp [lindex $retStat $j ] ;# {-SendPort 1/9 -StaPort 1/10 -Stream streamName0 -SendTra {3011313 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0} -RecTra {0 3011273 0 0 22.4 295.7 26.0 0.0 271.6 2.2}}
#	          CommonArgsGet $retStatTemp -RecTra recTra
#	          set rxPayloadErrors [lindex $recTra 2 ] ;#接收端口的  RX_PAYLOAD_ERRORS 
#	          
#	          # 只要发现有一次 S_RX_PAYLOAD_ERRORS 值不为0，就报错，退出
#	          if {0 != $rxPayloadErrors } {
#	             return Err010
#	          }
#	       }
	    } else {
	       ::TestLib::ShowTraceMessage -level 10 -color red -msg "(QosCheckNoFullStremMixData0028), 停流失败！ "
	       return Err010
	    }
		
	    #是否核对发送、接收报文个数
		if {([info exists forwardPktNum])} { 
	        ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(QosCheckNoFullStremMixData0030), 核对发送、接收报文个数"
	        set retFlag [ QosCheckStremPktNum -ReturnPktNum $returnPktNum -ForwardPktNum $forwardPktNum \
                    -PktLen $pktLenT ]
		    
		} ;# if

	    #是否核对采样报文
		if {([info exists forwardMix])} { 
		    CommonArgsGet $temp_GetStreamData -l_rx_pps rx_pps -l_rx_line_bps rx_line_bps	    
#		    puts "QosCheckNoFullStremMixData  rx_pps:$rx_pps"
#		    puts "QosCheckNoFullStremMixData  rx_line_bps:$rx_line_bps"
	
	        #核对采样报文
	        ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(QosCheckNoFullStremMixData0040), 核对采样报文"
	        CommonArgsGet $temp_GetStreamData -l_rx_pps rx_pps -l_rx_line_bps rx_line_bps
	        
		    #是否判断采样过程中抖动的范围
			if {([info exists allowErrorFittery])} { 
		        set retFlagTemp [ QosDealWithStremMixData -streamData $temp_GetStreamData \
		                                -l_rx_pps $rx_pps -l_rx_line_bps $rx_line_bps -ForwardMix $forwardMix \
			                            -PktLen $pktLenT -AllowError $allowError -sampleTimes $sampleTimes \
			                            -AllowErrorFittery $allowErrorFittery ]
			} else {
		        set retFlagTemp [ QosDealWithStremMixData -streamData $temp_GetStreamData \
		                                -l_rx_pps $rx_pps -l_rx_line_bps $rx_line_bps -ForwardMix $forwardMix \
			                            -PktLen $pktLenT -AllowError $allowError -sampleTimes $sampleTimes \
			                            ]
			
			};# end if
					

	        
	        set retFlagTemp [ lindex $retFlagTemp 0 ]
	        if {0 != $retFlagTemp} {
				set retFlag "FALSE"
	        }
		} ;# end if
        
        #===================================   判断所有队列的 rx_line_bps 总和   START  ====================
        if {"FALSE" != $forwardTotalBps} {
	        set totalRxLinebps 0.0 ; #所有队列的 rx_line_bps 总和    
	        for {set j 0} { $j < $streamSum } {incr j 1} {
	             set rxLineBps [lindex $rx_line_bps $j]
	             set totalRxLinebps [expr $totalRxLinebps + $rxLineBps ]
	        }
	        
	        set cutValue        [expr abs([ expr $totalRxLinebps - $forwardTotalBps ]) ] ;#获取当前比值跟期望比值的差距值
	        set temp            [expr $cutValue * 1.0 / $forwardTotalBps * 1.0 ]         ;#获取当前比值跟期望比值的误差 
	        
	        #判断是否在允许的误差范围内	                     
	#	    #如果是小流量(小于2M)，并且是长包（若包长是随机值的话，就取中间值,大于1000）的情况下，误差要稍微放大一些;否则，使用正常误差                    
	#	    set allowError [ QosCheckAllowError -RxLinebps $totalRxLinebps -PktLen $pktLenT \
	#		                      -AllowErrorNormal $allowErrorBackUp ]
	        #如果 temp 不只2位小数，就强制格式转换为2位小数，多余位四舍五入
	        set temp          [format %.2f  $temp ]
	        if { $temp <= $allowErrorBackUp } {
	             ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(QosCheckNoFullStremMixData0090),包长为 $pktLenT , \
	  	         所有队列的 rx_line_bps 总和是 $totalRxLinebps Mbps，跟预期值 $forwardTotalBps Mbps 的误差为 $temp , \
	  	         在误差范围 $allowErrorBackUp 内, 正常 ！ "
	        } else {
	             ::TestLib::ShowTraceMessage -level 10 -color red -msg "(QosCheckNoFullStremMixData0100),包长为 $pktLenT , \
	  	         所有队列的 rx_line_bps 总和是 $totalRxLinebps Mbps，跟预期值 $forwardTotalBps Mbps 的误差为 $temp , \
	  	         不在误差范围 $allowErrorBackUp 内, 不正常 ！ "
		  	          
		 	     set retFlag "FALSE"
	        }
        }
        #===================================   判断所有队列的 rx_line_bps 总和   END  ====================
		        
        
        #blackStreamFlg 为 true，表明要处理一条背景流，即从对端口发来的流
        if {"TRUE" == $blackStreamFlg} {

	        #核对背景流的采样报文,默认端口速率是1G,即1000M
	        CommonArgsGet $temp_GetStreamData -BlackStream_rx_line_bps blackStream_rx_line_bps
	        set retFlagTemp [ QosCheckBlackStrem -BlackStream_rx_line_bps $blackStream_rx_line_bps -AllowError $allowError ]

	        set retFlagTemp [ lindex $retFlagTemp 0 ]

            if {0 != $retFlagTemp} {
				return Err010
            }
        }       

    };#for
    
    #返回
    if {"TRUE" == $retFlag} {
      return "0 Suc001 -CreatStreamList $temp_CreatStreamList"
    } else {
      return Err010
    }

} ;# end of proc



proc  checkRxLinebpsFittery { args } {
      puts "==checkRxLinebpsFittery==$args"
      
      CommonArgsGet $args -pktLen pktLen -strNO strNO -allowError allowError -forwardValue forwardValue
      set streamData [lindex $args 0] 
      # strNO 的值为 0 1 2 3 4 5 6 7 ，分别对应建流的时候的流序号。暂时只支持 8 条流
      switch $strNO {
    	0  { CommonArgsGet $streamData -stream0Fittery stream0Fittery ; \
    		 CommonArgsGet $stream0Fittery -rxlinebpsMin rxlinebpsMin -rxlinebpsMax rxlinebpsMax ; \
             set cutValue [expr ( $rxlinebpsMax - $rxlinebpsMin ) / 1000000.0 ] ; \
             set retFlag [getRxLinebpsFitteryError -thisValue $cutValue -pktLen $pktLen \
                                                  -strNO $strNO -allowError $allowError \
                                                  -Min $rxlinebpsMin -Max $rxlinebpsMax \
                                                  -forwardValue $forwardValue] ; \
    	   }
    	1  { CommonArgsGet $streamData -stream1Fittery stream1Fittery ; \
    		 CommonArgsGet $stream1Fittery -rxlinebpsMin rxlinebpsMin -rxlinebpsMax rxlinebpsMax ; \
    		 set cutValue [expr ( $rxlinebpsMax - $rxlinebpsMin ) / 1000000.0 ] ; \
             set retFlag [getRxLinebpsFitteryError -thisValue $cutValue -pktLen $pktLen \
                                                  -strNO $strNO -allowError $allowError \
                                                  -Min $rxlinebpsMin -Max $rxlinebpsMax \
                                                  -forwardValue $forwardValue] ; \
    	   }
    	2  { CommonArgsGet $streamData -stream2Fittery stream2Fittery ; \
    		 CommonArgsGet $stream2Fittery -rxlinebpsMin rxlinebpsMin -rxlinebpsMax rxlinebpsMax ; \
             set cutValue [expr ( $rxlinebpsMax - $rxlinebpsMin ) / 1000000.0 ] ; \
             set retFlag [getRxLinebpsFitteryError -thisValue $cutValue -pktLen $pktLen \
                                                  -strNO $strNO -allowError $allowError \
                                                  -Min $rxlinebpsMin -Max $rxlinebpsMax \
                                                  -forwardValue $forwardValue] ; \
    	   }
    	3  { CommonArgsGet $streamData -stream3Fittery stream3Fittery ; \
    		 CommonArgsGet $stream3Fittery -rxlinebpsMin rxlinebpsMin -rxlinebpsMax rxlinebpsMax ; \
             set cutValue [expr ( $rxlinebpsMax - $rxlinebpsMin ) / 1000000.0 ] ; \
             set retFlag [getRxLinebpsFitteryError -thisValue $cutValue -pktLen $pktLen \
                                                  -strNO $strNO -allowError $allowError \
                                                  -Min $rxlinebpsMin -Max $rxlinebpsMax \
                                                  -forwardValue $forwardValue] ; \
    	   }
    	4  { CommonArgsGet $streamData -stream4Fittery stream4Fittery ; \
    		 CommonArgsGet $stream4Fittery -rxlinebpsMin rxlinebpsMin -rxlinebpsMax rxlinebpsMax ; \
             set cutValue [expr ( $rxlinebpsMax - $rxlinebpsMin ) / 1000000.0 ] ; \
             set retFlag [getRxLinebpsFitteryError -thisValue $cutValue -pktLen $pktLen \
                                                  -strNO $strNO -allowError $allowError \
                                                  -Min $rxlinebpsMin -Max $rxlinebpsMax \
                                                  -forwardValue $forwardValue] ; \
    	   }
    	5  { CommonArgsGet $streamData -stream5Fittery stream5Fittery ; \
    		 CommonArgsGet $stream5Fittery -rxlinebpsMin rxlinebpsMin -rxlinebpsMax rxlinebpsMax ; \
             set cutValue [expr ( $rxlinebpsMax - $rxlinebpsMin ) / 1000000.0 ] ; \
             set retFlag [getRxLinebpsFitteryError -thisValue $cutValue -pktLen $pktLen \
                                                  -strNO $strNO -allowError $allowError \
                                                  -Min $rxlinebpsMin -Max $rxlinebpsMax \
                                                  -forwardValue $forwardValue] ; \
    	   }
    	6  { CommonArgsGet $streamData -stream6Fittery stream6Fittery ; \
    		 CommonArgsGet $stream6Fittery -rxlinebpsMin rxlinebpsMin -rxlinebpsMax rxlinebpsMax ; \
             set cutValue [expr ( $rxlinebpsMax - $rxlinebpsMin ) / 1000000.0 ] ; \
             set retFlag [getRxLinebpsFitteryError -thisValue $cutValue -pktLen $pktLen \
                                                  -strNO $strNO -allowError $allowError \
                                                  -Min $rxlinebpsMin -Max $rxlinebpsMax \
                                                  -forwardValue $forwardValue] ; \
    	  }    	
    	7  { CommonArgsGet $streamData -stream7Fittery stream7Fittery ; \
    		 CommonArgsGet $stream7Fittery -rxlinebpsMin rxlinebpsMin -rxlinebpsMax rxlinebpsMax ; \
             set cutValue [expr ( $rxlinebpsMax - $rxlinebpsMin ) / 1000000.0 ] ; \
             set retFlag [getRxLinebpsFitteryError -thisValue $cutValue -pktLen $pktLen \
                                                  -strNO $strNO -allowError $allowError \
                                                  -Min $rxlinebpsMin -Max $rxlinebpsMax \
                                                  -forwardValue $forwardValue] ; \
    	  }
    	default {::TestLib::ShowTraceMessage -level 10 -color red -msg "(checkRxLinebpsFittery) 队列 ID 号传入有误，暂时只支持：0 1 2 3 4 5 6 7 " ; \
    		     set retFlag "FALSE" }
      }
      
      return $retFlag
}

proc  getRxLinebpsFitteryError { args } {
      puts "==getRxLinebpsFitteryError==$args"
      
      
      CommonArgsGet $args -thisValue thisValue -pktLen pktLen -strNO strNO \
                          -allowError allowError -forwardValue forwardValue \
                          -Min rxlinebpsMin -Max rxlinebpsMax

      if {0 > $forwardValue } {
	  	  ::TestLib::ShowTraceMessage -level 10 -color pink -msg "(getRxLinebpsFitteryError),包长为 $pktLen ，\
	  	                          队列 $strNO 的流的 rx_line_bps 期望值为 $forwardValue Mbps,小于 0 , 不正常 ！"
	       # 因为 Xstream 跟 testcenter 在测试抖动的时候，产生的误差不一致，Xstream误差过大，会导致用例失败。所以暂时返回 ok ，让用例先执行下去。
	       return "TRUE"
#          return "FALSE"
      } elseif { 0 == $forwardValue } {
          if { $thisValue == $forwardValue } {
		  	 ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(getRxLinebpsFitteryError),包长为 $pktLen ，\
		  	                          队列 $strNO 的流的 rx_line_bps 抖动范围是最小值 $rxlinebpsMin , 最大值 $rxlinebpsMax， \
		  	                          抖动最大最小差值是 $thisValue Mbps , 期望值为 $forwardValue Mbps,误差值为 0.0 , \
		  	                          在误差范围 $allowError 内, 正常 ！"
		     return "TRUE"       ; #返回类型
          } else {
		  	 ::TestLib::ShowTraceMessage -level 10 -color pink -msg "(getRxLinebpsFitteryError),包长为 $pktLen ，\
		  	                          队列 $strNO 的流的 rx_line_bps 抖动范围是最小值 $rxlinebpsMin , 最大值 $rxlinebpsMax， \
		  	                          抖动最大最小差值是 $thisValue Mbps , 而期望值为 $forwardValue Mbps, 不正常 ！"
		     
		     # 因为 Xstream 跟 testcenter 在测试抖动的时候，产生的误差不一致，Xstream误差过大，会导致用例失败。所以暂时返回 ok ，让用例先执行下去。
		     return "TRUE"
#		     return "FALSE"
          }

      } else {
	      
#	      set cutValue            [expr abs([ expr $thisValue - $forwardValue ]) ]
#	      set temp                [expr $cutValue * 1.0 / $forwardValue * 1.0 ] 

	      set temp                [expr $thisValue * 1.0 / $forwardValue * 1.0 ]
	      #如果 temp 不只2位小数，就强制格式转换为2位小数，多余位四舍五入
	      set temp          [format %.2f  $temp ]
		  if {$temp <= $allowError } {
		  	 ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(getRxLinebpsFitteryError),包长为 $pktLen ，\
		  	                          队列 $strNO 的流的 rx_line_bps 抖动范围是最小值 $rxlinebpsMin , 最大值 $rxlinebpsMax， \
		  	                          抖动最大最小差值是 $thisValue Mbps , 期望值为 $forwardValue Mbps,误差值为 $temp , \
		  	                          在误差范围 $allowError 内, 正常 ！"
		     return "TRUE"       ; #返回类型
		  } else {
		  	 ::TestLib::ShowTraceMessage -level 10 -color red -msg "(getRxLinebpsFitteryError),包长为 $pktLen ，\
		  	                          队列 $strNO 的流的 rx_line_bps 抖动范围是最小值 $rxlinebpsMin , 最大值 $rxlinebpsMax， \
		  	                          抖动最大最小差值是 $thisValue Mbps , 期望值为 $forwardValue Mbps,误差值为 $temp , \
		  	                          不在误差范围 $allowError 内, 不正常 ！"
		     # 因为 Xstream 跟 testcenter 在测试抖动的时候，产生的误差不一致，Xstream误差过大，会导致用例失败。所以暂时返回 ok ，让用例先执行下去。
		     return "TRUE"
#		     return "FALSE"
		  };#if allowError
	      
      } ;#if  forwardValue 
      

}

proc  checkTotalRxLinebpsFittery { args } {
      puts "==checkTotalRxLinebpsFittery==$args"
      CommonArgsGet $args  -pktLen pktLen -sampleTimes sampleTimes  \
                           -tsStrNO tsStrNO -lenTsStrNO lenTsStrNO  \
                           -allowError allowError -forwardValue forwardValue
      set retFlag "TRUE";
      
      set lappendData {}
	  set streamData [lindex $args 0]
      for {set z 0} { $z < $sampleTimes } {incr z 1} {
        set thisTotalRxLinebps 0.0
        for {set s 0 } {$s < $lenTsStrNO } {incr s} {
            set strNOTemp     [lindex $tsStrNO $s]
            
            # strNOTemp 的值为 0 1 2 3 4 5 6 7 ，分别对应建流的时候的流序号。暂时只支持 8 条流
	        switch $strNOTemp {
	        	0  { CommonArgsGet $streamData -strLinebps0 strLinebps0 ; \
	        		 set LinebpsVal [lindex $strLinebps0 $z] ; \
	        	     set thisTotalRxLinebps [expr $thisTotalRxLinebps + $LinebpsVal ] \
		           }
	        	1  { CommonArgsGet $streamData -strLinebps1 strLinebps1 ; \
	        		 set LinebpsVal [lindex $strLinebps1 $z] ; \
	        	     set thisTotalRxLinebps [expr $thisTotalRxLinebps + $LinebpsVal ] \
		           }
	        	2  { CommonArgsGet $streamData -strLinebps2 strLinebps2 ; \
	        		 set LinebpsVal [lindex $strLinebps2 $z] ; \
	        	     set thisTotalRxLinebps [expr $thisTotalRxLinebps + $LinebpsVal ] \
		           }
	        	3  { CommonArgsGet $streamData -strLinebps3 strLinebps3 ; \
	        		 set LinebpsVal [lindex $strLinebps3 $z] ; \
	        	     set thisTotalRxLinebps [expr $thisTotalRxLinebps + $LinebpsVal ] \
		           }
	        	4  { CommonArgsGet $streamData -strLinebps4 strLinebps4 ; \
	        		 set LinebpsVal [lindex $strLinebps4 $z] ; \
	        	     set thisTotalRxLinebps [expr $thisTotalRxLinebps + $LinebpsVal ] \
		           }
	        	5  { CommonArgsGet $streamData -strLinebps5 strLinebps5 ; \
	        		 set LinebpsVal [lindex $strLinebps5 $z] ; \
	        	     set thisTotalRxLinebps [expr $thisTotalRxLinebps + $LinebpsVal ] \
		           }
	        	6  { CommonArgsGet $streamData -strLinebps6 strLinebps6 ; \
	        		 set LinebpsVal [lindex $strLinebps6 $z] ; \
	        	     set thisTotalRxLinebps [expr $thisTotalRxLinebps + $LinebpsVal ] \
		           }
	        	7  { CommonArgsGet $streamData -strLinebps7 strLinebps7 ; \
	        		 set LinebpsVal [lindex $strLinebps7 $z] ; \
	        	     set thisTotalRxLinebps [expr $thisTotalRxLinebps + $LinebpsVal ] \
		           }
	        	default {::TestLib::ShowTraceMessage -level 10 -color red -msg "(checkTotalRxLinebpsFittery) 队列 ID 号传入有误，暂时只支持：0 1 2 3 4 5 6 7 " \
	        		     return "FALSE" \
	        		     }
	            
	            puts "thisTotalRxLinebps==$s==:$thisTotalRxLinebps"
	        }; #switch
        } ;#for lenTsStrNO 
        lappend lappendData $thisTotalRxLinebps ;
      } ;# for  sampleTimes
	                
#	  ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(checkTotalRxLinebpsFittery) lappendData:$lappendData "               
	  
	  #升序
	  set lappendData [lsort -real -increasing $lappendData];
#	  ::TestLib::ShowTraceMessage -level 10 -color blue -msg "(checkTotalRxLinebpsFittery) lappendData 升序之后:$lappendData "
	  
	  #最小最大值
	  set totalRxLinebpsMix [lindex $lappendData 0 ]
	  set totalRxLinebpsMax [lindex $lappendData [expr $sampleTimes - 1 ] ]
	  #差值
#	  set ave_totalrxlinebps [expr ( $totalRxLinebpsMix + $totalRxLinebpsMax ) / 1000000.0 / 2.0] ;
	  set cutValue [expr ( $totalRxLinebpsMax - $totalRxLinebpsMix ) / 1000000.0 ] ;
      #平均值跟预期值比较，判断是否在误差范围内
      set retFlag [getRxLinebpsFitteryError -thisValue $cutValue -pktLen $pktLen \
                                          -strNO $tsStrNO -allowError $allowError \
                                          -Min $totalRxLinebpsMix -Max $totalRxLinebpsMax \
                                          -forwardValue $forwardValue ] ; 

     return $retFlag

}

#proc getTrimFloatValue { args } {
#
#    #获取传入参数
#	CommonArgsGet $args -Number number -Left left  -Flag flag
#	
#	#如果传入的值不只三位小数，就强制格式转换为3位小数，多余位直接删除
#    set number  [format %.2f  $number ]
#    
#    set number  [ TrimFloat -Number number -Left 2  -Flag "TRUE" ]
#    
#    return "0 succ -ReValue $number "
#}

#!!================================================================
#  过 程 名：   TrimFloat
#  函数说明:   按输入的保留位数和舍入方法处理小数的精度
#  参数说明：
#               -number:	待处理的小数
#               -left:		要保留的小数位的位数,即返回的小数位数.默认保留2位小数
#               -flag:	    下一小数位是否四舍五入 ,默认四舍五入
#             
#  返 回 值：  
#                执行成功；           
#					返回 0 成功码；    
#                执行失败；            
#                	返回错误码;
#  注意事项：
#  使用实例：
#		    
#		   
#  对应命令： 
#  
#  作    者： liuxiaohao lwx239864
#  生成时间： 2014-10-15 15:34:32
#  修改纪录： dengwenxian  20150109  修改参数传入方式、变量命名、注释修改  
#               
#!!================================================================
proc TrimFloat { args } {

    set left 2      ; # 默认保留2位小数
    set flag "TRUE" ; # 下一小数位是否四舍五入 ,默认四舍五入

    #获取传入参数
	CommonArgsGet $args -Number number -Left left  -Flag flag
	
    set flag [string toupper $flag]  ; # 转大写

    #取得整数部分到IntPart
	regexp {\-*([0-9]+)\.} $number IntPart; 
	set IntPart [string trimright $IntPart {\.}]; 
    
    #取得带小数点的小数部分到FloatPart
	regexp {\.([0-9]+)} $number FloatPart; 
    
    #取得要保留的最后一位的数值待后续处理
	set ValueOfleft [string index $FloatPart $left]; 
    
    #取得要保留的最后一位的下一位的数值用作判断
	set ValueOfNext [string index $FloatPart [expr $left + 1]];
	
    #flag 为 TRUE 则，下一位进行四舍五入； 为 FALSE 则，下一位不做任何处理直接去除
	if { [expr 4 < $ValueOfNext] && "TRUE" == $flag } {  
		  incr ValueOfleft;
	}
	
    #更新最后一位
	set FloatPart [string replace $FloatPart $left $left $ValueOfleft];
    
    #去掉小数部分的多余位
	set FloatPart [string range $FloatPart 0 $left]; 
    
    #用处理后的小数部分和原整数部分组合成结果
	set result [append IntPart $FloatPart]; 
	
	return $result;
}


#==================================================================
#  过 程 名：   IasCommonDelay
#  函数说明：   系统延时等待
#  参数说明：
#               -Time:  (可选)延时时间(以秒为单位);
#				
#  注意事项：	
#  使用实例：   IasCommonDelay -Time 20
#  对应命令：	after 20
#               
#  作    者：   ZhT04380 
#  修改纪录：modified by zhengtao ht00603 注释掉每秒输出的提示信息
#!!================================================================

proc IasCommonDelay { args } {
	#初始化变量
	set time 60
    #分离参数
    CommonArgsGet $args -Time time
	ShowTraceMessage -level 10 -msg "AW(IasCommonDelay)系统即将被延时$time 秒!"
    
	#时间转换为以毫秒为单位
	#set time [expr $time*1000]
	
	for {set i 0} {$i < $time} {incr i} {
		after 1000
#		puts ">>需等待$time秒,已经等待[expr $i + 1]秒..."
	}
	
	ShowTraceMessage -level 10 -msg "AW(IasCommonDelay)系统被延时$time 秒成功!"
  	
  	return "0"
} ;# end of proc

#=======================================================
#----------------- 测 试 记 录 -------------------------
#=======================================================
# IasCommonAftertime -Time 20000
